import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class TicketAnalytics {

    /**
     * TASK 1:
     * Return a list containing the names of all VIP passengers.
     * Each passenger name must appear only once.
     */
    public static List<String> findVipPassengerNames(Stream<Ticket> tickets) {
        return tickets.map(Ticket::getPassenger).filter(Passenger::isVip).distinct().map(Passenger::getName).toList();

    }

    /**
     * TASK 2:
     * Compute and return the average ticket price.
     * If there are no tickets, return 0.0.
     */
    public static double averageTicketPrice(Stream<Ticket> tickets) {
        return tickets.mapToDouble(Ticket::getPrice).average().getAsDouble();
    }

    /**
     * TASK 3:
     * Group all tickets by their destination country.
     * The key is the Country, the value is a list of tickets flying there.
     */
    public static Map<Country, List<Ticket>> groupByDestination(Stream<Ticket> tickets) {
        return tickets.collect(Collectors.groupingBy(ticket -> ticket.getFlight().getDestination(), Collectors.toList()));
    }

    /**
     * TASK 4:
     * For each destination country, count how many DISTINCT passengers
     * are flying there.
     */
    public static Map<Country, Long> countPassengersPerDestination(Stream<Ticket> tickets) {
        return tickets.collect(Collectors.groupingBy(ticket -> ticket.getFlight().getDestination(), Collectors.counting()));
    }

    /**
     * TASK 5:
     * Return the three most expensive tickets,
     * ordered from most expensive to least expensive.
     */
    public static List<Ticket> top3MostExpensive(Stream<Ticket> tickets) {
        return tickets.sorted(Comparator.comparingDouble(Ticket::getPrice).reversed()).limit(3).toList();
    }

    /**
     * TASK 6:
     * Return a set of flight numbers where the flight duration
     * is strictly longer than 5 hours.
     */
    public static Set<String> longFlights(Stream<Ticket> tickets) {
       return tickets.filter(ticket -> ticket.getFlight().getDurationMinutes()>300).map(ticket -> ticket.getFlight().getFlightNumber()).collect(Collectors.toSet());
    }

    /**
     * TASK 7:
     * For each destination country, determine the most expensive ticket.
     * If a country has no tickets, it should not appear in the map.
     */
    public static Map<Country, Optional<Ticket>> mostExpensivePerDestination(Stream<Ticket> tickets) { // Collectors.maxBy(selects the max element), comparingDouble, compares the ticket by price.
        return tickets.collect(Collectors.groupingBy(ticket -> ticket.getFlight().getDestination(), Collectors.maxBy(Comparator.comparingDouble(Ticket::getPrice))));
    }

    /**
     * TASK 8:
     * Compute the total revenue generated by VIP passengers only.
     */
    public static double vipRevenue(Stream<Ticket> tickets) {
        return tickets.filter(ticket -> ticket.getPassenger().isVip()).mapToDouble(Ticket::getPrice).sum();
    }

    /**
     * TASK 9 (BOSS LEVEL):
     * Determine which destination country generated the highest total revenue.
     * Return Optional.empty() if there are no tickets.
     */
    public static Optional<Country> topRevenueDestination(Stream<Ticket> tickets) {
        return tickets.collect(Collectors.groupingBy(ticket -> ticket.getFlight().getDestination(),Collectors.summingDouble(Ticket::getPrice))).entrySet().stream().max(Map.Entry.comparingByValue()).map(Map.Entry::getKey);
        /* start with a stream of tickets
            turn stream into a map using .collect(Collectors.groupingBy())
            Collectors.summingDouble(Ticker::getPrice) -- instead of collecting tickets into a list, we sum them up, so it becomes Map<Country, Double>
            for example GERMANY -> 800.0, USA -> 1750.0
            .entrySet() to compare by revenue, not by country name
            .stream() turn entriees back into a stream, so that java can process them again.
            .max(Map.Entry.comparingByValue()) asks which entry has the largest double value so java compares the 800.0 vs 1750.0,
            .map(Map.Entry::getKey) we dont want the entry anymore we just want the country so (USA,1750.0) -> USA final type becomes Optional<Country>
                     */
    }
}
